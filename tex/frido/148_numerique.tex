% This is part of Mes notes de mathématique
% Copyright (C) 2010-2013,2016,2018
%   Laurent Claessens
% See the file LICENCE.txt for copying conditions.

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\section{Estimation de l'ordre de convergence}
%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\begin{definition}[\cite{ooZMYRooKsvblD}]
    Nous disons que la suite \( (x_n)\) de limite \( x\) est \defe{convergente d'ordre \( q\)}{convergence!ordre} pour $q>1$ s'il existe \( \mu>0\) tel que
    \begin{equation}
        \lim_{k\to \infty} \frac{ | x_{k+1}-x | }{ | x_k-x |^q }=\mu.
    \end{equation}
    En particulier :
    \begin{itemize}
        \item
    la convergence d'ordre 2 est dite quadratique,
        \item
    la convergence d'ordre 3 est dite cubique,
        \item 
    la convergence d'ordre 4 est dite quartique.
    \end{itemize}
\end{definition}

Comment estimer numériquement l'ordre \( p\) de convergence de la méthode ? Soit une suite \( (x_n)\) convergente vers \( \alpha\). Considérons les \( 4\) termes \( x_{n-3}\), \( x_{n-2}\), \( x_{n-1}\), \( x_n\). Alors nous pouvons écrire l'approximation
\begin{equation}
    \frac{ | x_n -x_{n-1}| }{ | x_{n-1}-x_{n-2} | }\simeq \left( \frac{ | x_{n-1}-x_{n-2} | }{ | x_{n-1}-x_{n-3} | } \right)^p.
\end{equation}
Cette approximation ne serait pas trop mauvaise tant que \( n\) est assez grand pour que la convergence soit bien engagée. Passons au logarithme :
\begin{equation}
    \ln \frac{ | x_n -x_{n-1}| }{ | x_{n-1}-x_{n-2} | }\simeq p\ln \left( \frac{ | x_{n-1}-x_{n-2} | }{ | x_{n-1}-x_{n-3} | } \right).
\end{equation}
et donc
\begin{equation}
    p\simeq \frac{ \ln\left( \frac{ | x_n -x_{n-1}| }{ | x_{n-1}-x_{n-2} } \right) }{ \ln \left(\frac{ | x_{n-1}-x_{n-2} | }{ | x_{n-1}-x_{n-3} | } \right)}.
\end{equation}
Avec cette approximation, en réalité nous calculons une suite \( (p_i)\) qui sont les approximations de \( p\) à partir des termes \( i\) à \(i+3 \) de la suite \( (x_n)\). Il s'agit d'une suite d'estimations de \( p\).

\begin{enumerate}
    \item
Dans le cas de la bisection, nous obtenons toujours \( p_i=1\).
\item
    Dans le cas de la méthode de Newton (\ref{SECooIKXNooACLljs}) nous avons \( p=2\). Mais les premières valeurs de \( p_i\) peuvent être aussi bien \( 0\) que \( 7\). Après quelques itérations pourtant les \( p_i\) se regroupent autour de \( 2\).
\end{enumerate}
En tout cas, le plus important est de savoir si \( p>1\) ou non. Rappel : nous voulons la superlinéarité parce que nous voulons utiliser le test d'arrêt de la différence entre deux termes, voir~\ref{NTooVXLXooXlAGEq}.

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\section{Autres méthodes}
%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

%---------------------------------------------------------------------------------------------------------------------------
\subsection{Méthode de Schröder}
%---------------------------------------------------------------------------------------------------------------------------

La formule est
\begin{equation}
    x_{n+1}=x_n-\frac{ f(x_n)f'(x_n) }{ f'(x_n)^2-f(x_n)f''(x_n) }
\end{equation}
Cette méthode est d'ordre \( 2\) pour toute racine et toute valeur de multiplicité. Le problème de cette méthode est qu'elle demande \( 3\) évaluations de \( f\). Son efficacité :
\begin{equation}
    E=\sqrt[3]{ 2 }\simeq 1.25
\end{equation}
Cela est donc moins efficace que Newton.

%---------------------------------------------------------------------------------------------------------------------------
\subsection{Halley}
%---------------------------------------------------------------------------------------------------------------------------

Il a \( p=3\) lorsque \( \alpha\) est racine simple. Mais encore \( p=1\) pour les racines multiples. Plus efficace que Newton pour les racines simples, mais même problème pour les racines multiples.

\begin{equation}
    x_{n+1}=x_n-\frac{ 2f(x_n)f'(x_n) }{ 2f'(x_n)^2-f(x_n)f''(x_n) }
\end{equation}

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\section{Méthode des sécantes variables}
%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\label{SECooIUEUooVcHAoc}

Si nous n'avons pas de formule analytique pour \( f\), mais seulement la possibilité de calculer \( f(x)\) pour tout \( x\). Newton ne fonctionne pas, mais la bisection fonctionne.

Nous pouvons approximer
\begin{equation}
    f'(x_n)=\frac{ f(x_n)-f(x_{n-1}) }{ x_n-x_{n-1} }.
\end{equation}
En substituant dans la formule de Newton, nous obtenons
\begin{equation}
    x_{n+1}=x_n-\frac{ f(x_n)(x_n-x_{n-1}) }{ f(x_n)-f(x_{n-1}) }.
\end{equation}

Il s'agit de prendre la droite qui passe par \( (x_{n-1},f(x_{n-1}))\) et par \( (x_n,f(x_n))\) et de prendre l'intersection de cette droite avec l'axe \( y=0\). Cela donne le \( x_{n+1}\).

Pour cette méthode, il ne faut pas seulement \( x_0\) mais également \( x_1\).

L'ordre de convergence est le nombre d'or
\begin{equation}    \label{EQooQEFCooUsGVjP}
    p=\frac{ 1-\sqrt{ 5 } }{ 2 }\simeq 1.618.
\end{equation}
Cela est donc superlinéaire.

La nombre d'évaluations est \( s=1\) (il y a deux apparitions de \( f\) dans la formule, mais l'une des deux est récupérée dans l'itération suivante). Donc l'efficacité est
\begin{equation}
    E=p.
\end{equation}
Donc bien efficace.

\begin{proposition}
    Si \( \alpha\) est racine simple, il existe un voisinage de \( \alpha\) tel que pour tout choix de \( x_0\), \( x_1\) dans ce voisinage, la méthode converge.
\end{proposition}

Psychologiquement, on est tenté de prendre \( x_0\) et \( x_1\) de part et d'autre de \( \alpha\) (pensant à la bisection), mais en réalité ce n'est pas obligatoire du tout et n'a aucune influence. Il faut seulement les prendre très proches de \( \alpha\).

\begin{remark}
    La méthode de la sécante est souvent écrite sous la forme
    \begin{equation}        \label{EQooYVKLooKTFjwv}
        x_{n+1}=\frac{ x_{n-1}f(x_n)-x_nf(x_{n-1}) }{ f(x_n)-f(x_{n-1}) }.
    \end{equation}
    C'est évidemment algébriquement équivalent.

    Les formules \eqref{EQooQEFCooUsGVjP} et \eqref{EQooYVKLooKTFjwv} ont toutes deux des erreurs de cancellation. Laquelle est la plus grave ?

    Dans la première, si la fraction est mal calculée, elle ne fait que modifier \( x_n\). C'est-à-dire qu'on peut espérer qu'à la prochaine itération, ça aille mieux. En tout cas, dans ce cas si la fraction est mal calculée, ça ne détruit pas tout.

    Dans la seconde, c'est la valeur elle-même qui risque d'être mal calculée. Et si la fraction est mal calculée, alors on casse complètement l'éventuel bonne approximation que nous avions déjà.
\end{remark}

%---------------------------------------------------------------------------------------------------------------------------
\subsection{Aitken}
%---------------------------------------------------------------------------------------------------------------------------

La méthode du \( \Delta^2\) de Aitken est une méthode d'accélération de la convergence.

Soit \( (x_n)\) une suite qui converge. Nous voudrions une nouvelle suite \( (y_n)\) telle que
\begin{equation}
    \lim_{n\to \infty} \frac{ y_n-\alpha }{ x_n-\alpha }
\end{equation}
C'est la définition d'une convergence accélérée.

La façon de faire est :
\begin{equation}
    y_n=\frac{ x_{n+2}x_n-x_{n+1}^2 }{ x_{n+2}-2x_{n+1}+x_n }=x_n-\frac{ (x_{n+1}-x_n) }{ x_{n+2}-2x_{x+1}+x_n }.
\end{equation}
La première expressions a deux cancellations (la seconde une seule) et de plus la première est $y_n$ elle-même alors que la seconde est une correction.

Donc la seconde expression est numériquement meilleure.

L'opérateur \( \Delta\) appliqué à une suite est :
\begin{equation}
    (\Delta x)_n=x_{n+1}-x_n
\end{equation}
Donc
\begin{equation}
    (\Delta^2x)_n= (\Delta x)_{n+1}-(\Delta x)_n=x_{n+2}-x_{n+1}-x_{n+1}+x_n=x_{n+2}-2x_{n+1}+x_n.
\end{equation}
L'accélération a alors la formule
\begin{equation}
    y_n=\frac{ (\Delta x)_n^2 }{ (\Delta^2x)_n }.
\end{equation}

Le problème est que ça accélère tellement que l'on arrive vite à des erreurs de cancellations, et donc à une précision en pics oscillants.

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\section{Équations algébrique}
%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

C'est une équation du type \( P(x)=0\) où \( P\) est un polynôme. Soit un polynôme de degré \( n\). Nous en savons des choses.

\begin{enumerate}
    \item
        L'équation a exactement \( n\) solutions dans \( \eC\) en comptant les multiplicités.
    \item
        Les racines complexes arrivent par paire complexes conjuguée. Elles sont donc toujours en nombre pair.
\end{enumerate}

Si donc nous avons \( n=3\), nous ne pouvons pas avoir \( 2\) racine réelles. Il y en a donc \( 1\) ou \( 3\) réelles. Pas zéro ni deux.

Quelques méthodes : Müller, matrice compagnon, Laguerre.

%---------------------------------------------------------------------------------------------------------------------------
\subsection{Résoudre un système linéaire}
%---------------------------------------------------------------------------------------------------------------------------

Pour résoudre un système linéaire d'équations, nous échelonnons la matrice du système. Soit à résoudre le système $Ax=b$ où
\begin{equation}
	\begin{aligned}[]
		A&=\begin{pmatrix}
			2   &   4   &   -6  \\
			1   &   5   &   3   \\
			1   &   3   &   2
		\end{pmatrix}, &\text{et}&&b=\begin{pmatrix}
			-4  \\
			10  \\
			5
		\end{pmatrix}.
	\end{aligned}
\end{equation}
En termes de problèmes, on écrit $F\big( x,(A,b) \big)=Ax-b$. La donnée de ce problème est le couple $(A,b)$.

En ce qui concerne l'algorithme, on pose comme premier problème
\begin{equation}
	F_1\big(x_1,(A_1,b_1)\big)=A_1x_1-b_1=0
\end{equation}
avec $A_1=A$ et $b_1=b$.

Ensuite, on commence à échelonner et le second problème est
\begin{equation}
	F_2\big(x_2,(A_2,b_2)\big)=A_2x_2-b_2=0
\end{equation}
avec
\begin{equation}
	\begin{aligned}[]
		A&=\begin{pmatrix}
			2   &   4   &   -6  \\
			0   &   3   &   6   \\
			0   &   1   &   5
		\end{pmatrix}, &\text{et}&&b=\begin{pmatrix}
			-4  \\
			12  \\
			13
		\end{pmatrix}.
	\end{aligned}
\end{equation}
Le troisième problème sera
\begin{equation}
	F_3\big(x_3,(A_3,b_3)\big)=A_3x_3-b_3=0
\end{equation}
avec
\begin{equation}
	\begin{aligned}[]
		A&=\begin{pmatrix}
			2   &   4   &   -6  \\
			0   &   3   &   6   \\
			0   &   0   &   3
		\end{pmatrix}, &\text{et}&&b=\begin{pmatrix}
			-4  \\
			12  \\
			3
		\end{pmatrix}.
	\end{aligned}
\end{equation}
Ce problème est facile à résoudre «à la main». Nous nous arrêtons donc ici avec l'algorithme, et nous trouvons le $x_3$ qui résous le problème $F_3$.

%---------------------------------------------------------------------------------------------------------------------------
\subsection{Caractéristiques}
%---------------------------------------------------------------------------------------------------------------------------

L'algorithme de résolution de systèmes linéaires d'équations a les propriétés suivantes, à mettre en contraste avec celles de Newton :
\begin{enumerate}

	\item
		Pour résoudre le problème numéro $n$, il n'a pas fallu résoudre le problème numéro $n-1$.
	\item
		Toutes les solutions $x_n$ des problèmes intermédiaires sont solutions du problème de départ. Nous avons $F_n(x,d_n)=0$ pour tout $n$ (ici, $d_n=(A_n,b_n)$).
	\item
		D'un problème à l'autre, les données changent énormément : la matrice échelonnée peut être très différente de la matrice de départ.

\end{enumerate}

%---------------------------------------------------------------------------------------------------------------------------
\subsection{Définitions}
%---------------------------------------------------------------------------------------------------------------------------

	Nous allons maintenant formaliser en donnant quelques définitions pour nommer les propriétés que nous avons vues. D'abord, un algorithme est une suite de problèmes. Un \defe{algorithme}{algorithme} pour résoudre un problème $F(x,d)=0$ est une suite de problèmes $\{F_n(x_n,d_n)=0\}_{n\in\eN}$.

\begin{definition}
	Un tel algorithme est dit  \defe{fortement consistant}{algorithme!fortement consistant} si pour toutes données admissibles $d_n$, on a
	\begin{equation}
		F_n(x,d_n)=0\quad\forall \;n,
	\end{equation}
	où $x$ est la solution de $F(x,d)=0$.
\end{definition}
L'algorithme des matrices est fortement consistant, mais pas l'algorithme de Newton.

\begin{definition}
	Un algorithme est \defe{consistant}{algorithme!consistant} si $\lim_{n\to\infty}F_n(x,d_n)=0$.
\end{definition}
Dans le cas de l'algorithme de Newton, c'est plutôt une telle consistance qu'on attend.

L'algorithme est dit \defe{stable}{algorithme!stable} si pour tout $n$ le problème correspondant est stable.  Dans ce cas, on note $K^{\mbox{num}}$ le  \defe{conditionnement relatif asymptotique}{conditionnement!relatif asymptotique} défini par
\begin{equation}
	K^{\mbox{num}}=\limsup_nK_n
\end{equation}
où $K_n$ est le conditionnement relatif du problème $F_n(x_n,d_n)=0$.

\begin{definition}      \label{DefAlgoConverge}
	Un algorithme est dit \defe{convergeant}{algorithme!convergeant} (en $d$) si pour tout $\epsilon>0$, il existe $N=N(\epsilon)$ et $\delta=\delta(N,\epsilon)$ tels que pour $n\geq0$ et $|d-d_n|<\delta$, on ait $|x(d)-x_n(d_n)|<\epsilon$.
\end{definition}

\begin{remark}      \label{RemConvAlgoNewton}
Dans le cas de l'algorithme de Newton, nous avons vu que la donnée $d_n$ du problème $F_n$ était en fait la même que la donnée initiale $d$, donc nous avons $d_n=d$, et par conséquent nous avons toujours $| d-d_n |<\delta$. Dans ce cas, la définition de la convergence revient à demander que la suite numérique des $x_n$ converge vers la solution $x$.
\end{remark}

\begin{remark}
Dans le cas des matrices par contre, les données sont très différentes les unes des autres, nous avons donc en général que $| d-d_n |>\delta$. Mais en revanche nous savons que tous les problèmes intermédiaires $F_n$ acceptent une solution unique\footnote{Nous n'envisageons que le cas où le déterminant est non nul.} $x_n(d_n)=x(d)$. Par conséquent, $| x_n(d_n)-x(d) |$ est toujours plus petit que $\epsilon$. L'algorithme des matrices est donc toujours un algorithme convergeant.
\end{remark}

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\section{Équations non linéaire}
%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Certains équations non linéaires sont résoluble explicitement, par exemples les polynômes de degré jusqu'à \( 4\) ou des choses comme
\begin{equation}
	\sin^2(x)+3\sin(x)+5=0.
\end{equation}
Mais ces exemples sont très rares.

Nous allons étudier des équations du type \( f(x)=0\), dans \( \eR\).

\begin{enumerate}
	\item
Un problème écrit sous la forme \( x=g(x)\) peut utiliser des théorèmes de points fixes.
\item
	Un problème sous la forme \( f(x)=0\) peut utiliser des méthodes de bisection, Newton ou autres.
\end{enumerate}
Il y a évidemment beaucoup de façons de transformer un problème pour passer d'une forme à l'autre.

\begin{example}
	Soit \( f(x)=x^2-a=0\) avec \( a>0\). Nous pouvons l'écrire
	\begin{equation}
		x^2+x-a=x
	\end{equation}
	qui donne une forme \( g(x)=x\) pour \( g(x)=x^2+x-a\).

	Ou encore \( x=\frac{ a }{ x }\) et donc \( g(x)=a/x\) (si par ailleurs on sait que \( x\neq 0\)). Notons que \( x\neq 0\) n'est pas une hypothèse très forte parce qu'on la vérifie directement sur \( a\).
\end{example}

\begin{example}
	Soit l'équation à résoudre
	\begin{equation}
		f(x)=x^2-2-\ln(x)=0
	\end{equation}
	Les solutions de cette équations peuvent être vues comme les intersections avec l'axe \( X\) du graphe \( y=x^2-2-\ln(x)\). Tracer peut donc aider. Par ailleurs, il faut noter que
	\begin{equation}
		\lim_{x\to \pm\infty} f(x)=\infty,
	\end{equation}
	donc les solutions sont certainement contenues dans un compact de \( \eR\).

	À part tracer nous pouvons écrire
	\begin{equation}
		x^2-2=\ln(x).
	\end{equation}
	Et là, ce sont deux fonctions dont nous pouvons tracer le graphe pour trouver graphiquement les points d'intersection. Une étude de fonction montre vite qu'il y a exactement deux solutions, qu'elles sont strictement positives. Pour trouver des bornes, il faut calculer par exemple pour \( x=2\) les valeurs de \( \ln(x)\) et \( x^2-2\) pour voir si le graphe de \( x^2-2\) est déjà plus haut.
\end{example}

La majorité des méthodes numériques de résolution d'équation du type \( f(x)=0\) ou \( x=g(x)\) seront sous la forme de suites. Avec questions à la clefs :
\begin{enumerate}
	\item
		Quel point de départ choisir ?
	\item
		Convergence ?
	\item
		Est-ce que la limite est bien une solution ?
	\item
		Vu que la limite est unique, comment faire si l'équation a plusieurs solutions ? (souvent c'est le choix du point initial qui va jouer sur ce point)
\end{enumerate}

\begin{normaltext}
	Si la fonction est très plate, il est possible d'avoir
	\begin{equation}
		| f(\tilde \alpha) |\leq \epsilon
	\end{equation}
	sans que \( \tilde \alpha\) ne soit une bonne approximation.

	Lorsqu'on fait tourner une méthode itérative résolvant \( f(x)=0\), il n'est pas suffisant de s'arrêter lorsque
	\begin{equation}
		f(x_n)\leq \epsilon_1.
	\end{equation}
	Il faut aussi s'assurer que, si \( \bar x\) est la solution exacte, \( | x_n-\bar x |\leq \epsilon_2\). Ici \( \epsilon_1\) et \( \epsilon_2\) sont deux «précisions» que nous nous fixons au départ.

	Évidemment, vérifier la condition \( | x_n-\bar x |\leq \epsilon_2\), il faudrait savoir \( \bar x\). Et savoir \( \bar x\) c'est justement le problème. Nous sommes donc amenés à faire des estimations de \( | x_n-\bar x |\).
\end{normaltext}

\begin{normaltext}
    Lorsque nous effectuons une méthode itérative, il faut donc contrôler deux grandeurs :
    \begin{subequations}
        \begin{align}
            | \bar x-x_n |\leq \epsilon_1\\
            | x_{n+1}-x_n |\leq \epsilon_2.
        \end{align}
    \end{subequations}
\end{normaltext}

\begin{proposition}
Soit \( p\) l'ordre de convergence de la suite \( (x_n)\) vers \( \bar x\). Si \( p>1\) et \( | x_{n+1}-x_n |\leq \epsilon_2\) alors \( | \bar x-x_n |\leq \epsilon_2\).
\end{proposition}

%---------------------------------------------------------------------------------------------------------------------------
\subsection{Méthode de bisection}
%---------------------------------------------------------------------------------------------------------------------------

Il y a ce théorème des valeurs intermédiaires.
\begin{theorem}
	Soit \( f\) continue sur \( \mathopen[ a , b \mathclose]\) telle que \( f(a)f(b)<0\). Alors il existe au moins une solution à l'équation \( f(x)=0\) sur l'intervalle \( \mathopen] a , b \mathclose[\).
\end{theorem}

Pour démarrer une bisection, il est toujours bon de prendre l'intervalle \( \mathopen[ a , b \mathclose]\) de façon à ne contenir qu'une seule solution.

Soit donc un premier intervalle \( \mathopen[ a_0 , b_O \mathclose]\) tel que \( f(a_0)f(b_0)<0\) et ne contenant qu'une seule solution. À chaque itération nous considérons la moitié de l'intervalle précédent, mais la moitié contenant la solution.

Le test d'arrêt de la méthode de bisection se base uniquement sur la taille de l'intervalle qui reste. En effet si nous avons
\begin{equation}
	| b_n-a_n |\leq \epsilon
\end{equation}
nous avons certainement
\begin{equation}
	| \bar x-x_n |\leq \frac{ \epsilon }{2}
\end{equation}
où \( x_n\) est le point du milieu de \( \mathopen[ a_n , b_n \mathclose]\).

\begin{normaltext}
    La fonction \( f\) n'intervient dans la méthode que via son signe, pas via ses valeurs exactes.
\end{normaltext}

\begin{normaltext}
    Notons que le théorème des valeurs intermédiaires n'est pas très puissant pour choisir l'intervalle de départ; penser à la fonction
    \begin{equation}
        f(x)=x^2-5
    \end{equation}
    sur l'intervalle \( \mathopen[ -10 , 10 \mathclose]\). Il y a bien deux solutions dans l'intervalle, mais elles sont invisibles du théorème des valeurs intermédiaires. La fonction \( x\mapsto x^2\) a sa solution en \( x=0\), mais elle aussi n'est pas visible.
\end{normaltext}

\begin{normaltext}
    Certes la méthodes de bisection assure la convergence vers une solution, mais elle n'assure pas la convergence monotone. Il peut arriver que \( | \bar x-x_n |<| \bar x-x_{n+1} |\). C'est le cas lorsque la solution est très proche du milieu de l'intervalle choisit. Le \( x_0\) est alors proche de \( \bar x\) alors que \( x_1\) sera à une distance de \( \bar x\) d'environ un quart de l'intervalle de départ.
\end{normaltext}

Supposons déjà avoir trouvé un intervalle \( \mathopen[ a , b \mathclose]\) dans lequel se trouve une unique solution à \( f(x)=0\). Voici un algorithme possible.

\lstinputlisting{tex/frido/codeSnip_1.py}

Plusieurs remarques :
\begin{enumerate}
    \item
Le fait de retourner le nombre d'itérations effectuées permet à l'utilisateur de savoir la précision et si le nombre maximum d'itérations est dépassé. Si ce \info{n} retourné est égal à \info{nmax}, l'utilisateur sait que le \info{x} retourné n'est pas fiable.
\item
    La ligne \info{from \_\_future\_\_ import division} fait en sorte que l'opération \info{/} est bien la division usuelle. Sinon, le défaut en python 2 est que \info{/} soit la division \emph{entière}, c'est-à-dire que \( 1/2=0\) en python 2.
    En python 3, le symbole \info{/} désigne bien la division usuelle, mais Sage utilise Python 2.
\item
    Même si l'intervalle \( \mathopen[ a , b \mathclose]\) contient plus d'une solution, la méthode fonctionne et donne une solution. Il est simplement éventuellement très compliqué de savoir laquelle.
\item
    Nous faisons \info{amp=toll+1} parce que nous voulons absolument lancer le cycle au moins une fois. Sinon, le \info{x} à retourner ne serait pas définit au moment de sortir du cycle (si le cycle n'est pas exécuté).
\item
    Calculer le point milieu d'un intervalle \( \mathopen[ a , b \mathclose]\) est par la formule \( (a+b)/2\) sauf que cette opération est numériquement dangereuse parce qu'à cause de l'arithmétique en précision finie, il est possible que cela tombe \emph{exactement} sur \( a\) ou \( b\). D'où le fait de calculer le point milieu par
    \begin{equation}
        x=a+\frac{ amp }{2}.
    \end{equation}
\item
    Dans le cas \info{Problème ZERO} nous déduisons \( f(x)=0\). Attention que c'est pas que \( f(x)=0\) mais simplement que en mettant \( x\) dans \( f\), la \emph{machine} retourne son zéro.

    Il peut cependant avoir une fonction telle que \( f(1)=10^{-50}\) et \( f(2)=0\). L'algorithme de bisection risque de s'arrêter si \( x_n=1\). Parce que la machine risque de calculer \( f(x_n)=0\).

    Quoi qu'il en soit, nous y mettons \info{amp=0} pour être sûr de sortir de la boucle dès la prochaine vérification.
\item
    Il y a moyen de sauver les valeurs de \( f(a)\) et \( f(x)\) pour ne pas les recalculer, et en particulier au moment de faire \info{b=x} nous pouvons poser \(\info{fa=fx}\).
\end{enumerate}

Si \( \tau\) est la précision de la solution voulue, nous pouvons fixer a priori le nombre d'itérations à faire grâce à la formule
\begin{equation}
    n\geq\left\lceil  \log_2\big( \frac{ b-a }{ \tau } \big)  \right\rceil.
\end{equation}
Il y a un ``\( \geq\)'' et non une égalité parce qu'en arithmétique numérique, le nombre obtenu à droite pourrait ne pas être le bon à \( 1\) près.

Ici pour \( \nu\in \eR\) le nombre \( \lceil\nu\rceil\) est le plus petit entier à être plus grand ou égal à \( \nu\).

\begin{normaltext}
    Notons l'importance de la continuité de \( f\). Par exemple que ferait la bisection sur la fonction \( f(x)=1/x\) pour l'intervalle $\mathopen[ -3 , 1 \mathclose]$ ?

    Il y a changement de signe sans avoir de racine.
\end{normaltext}

Vu que \( 2^{10}\) est déjà \( 1024\). Donc si on veut de la précision de l'ordre de \( 1/1000\), dix itérations suffisent. Si donc nous avons besoin de \( 200\) itérations pour atteindre la précision voulue, c'est l'occasion de trouver un intervalle plus petit. Par exemple en traçant la fonction, en faisant un zoom et en trouvant des valeurs de \( a\) et \( b\) qui sont déjà proches.


\begin{normaltext}
    Dans le monde réel, il arrive souvent d'utiliser une méthode de bisection pour se donner un point de départ pour une autre méthode.
\end{normaltext}

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\section{Efficacité}
%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\begin{definition}
    L'\defe{efficacité}{efficacité!d'une méthode itérative} est le nombre
    \begin{equation}
        E=\sqrt[s]{ p }
    \end{equation}
    où \( p\) est l'ordre de convergence de la méthode et \( s\) est le nombre de fois qu'il faut calculer une valeur de la fonction à chaque itération (nous ne comptons pas l'initialisation).
\end{definition}
Que le nombre de d'évaluations de \( f\) intervienne est logique parce que chaque évaluation provoque une erreur possible.

\begin{example}[Bisection]
    Pour la méthode de bisection, nous avons \( s=1\) parce que chercher \( x_{n+1}\), il faut seulement calculer \( f(x_n)\).
\end{example}

\begin{example}[Newton]
    Pour l'algorithme de Newton nous avons \( p=2\) et il y a deux évaluations à chaque itération (une fois \( f\) et une fois \( f'\)), donc \( s=2\) et \( E=\sqrt{ 2 }\).
\end{example}

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\section{Exemples sous forme d'exercices}
%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\begin{example}
    
    Nous supposons une machine acceptant \( 5\) chiffres significatifs. Elle retient les nombres sous la forme \( \pm 0.x\cdots\times 10^{\ldots}\).
    
    \( x=1.403\), \( y=0.4112\times 10^{-3}\), \( z=-0.4111\times 10^{-3}\). 

    Soient
            \( a=(x\oplus y)\oplus z\) et  \( b=(y\oplus z)\oplus x\).

    \begin{enumerate}
        \item
     D'abord la calculer à la main. 
        \item
     Quel est le calcul préférable ?
 \item
     Donner l'erreur relative avec \( 3\) chiffres significatifs.
    \end{enumerate}

Dans le cas du calcul à la main, il faut en faire un seul parce que, algébriquement, \( a=b\).

Nous avons \( x=1.403\), \( y=0.0004112\) et \( z=-0.0004111\). Et la somme donne :
\begin{equation}
    a=b=1.4030001=0.14030001\times 10^1.
\end{equation}

Faisons d'abord la normalisation de \( x\), c'est-à-dire \( \fl(x)\).
\begin{equation}
    \fl(x)=0.1403\times 10^1.
\end{equation}
et \( y\) est déjà normalisé :
\begin{equation}
    \fl(y)=0.4112\times 10^{-3}.
\end{equation}
Il n'y a pas d'erreurs d'assignation pour ces deux nombres. 

Pour faire la somme, il faudra déjà un peu casser les nombres pour les écrire de façon à pouvoir les sommer. En effet, il faut écrire les deux nombres avec le même exposant de \( 10\) (le plus grand), pour pouvoir les mettre en colonne :
\begin{subequations}
    \begin{align}
        0.1404\times 10^1&\to 0.1404\times 10^1\\
        0.4112\times 10^{-3}&\to 0.00004\times 10^1.
    \end{align}
\end{subequations}
La somme donne \( 0.14034\times 10 ^1\). Et ça, c'est à nouveau arrondi. Le premier chiffre supprimé est un \( 4\), donc 
\begin{equation}
    x\oplus y=0.1403\times 10^1.
\end{equation}
Et là on remarque que nous avons la même chose que \( x\). C'est un classique du calcul numérique.

Nous avons aussi
\begin{equation}
    \fl(z)=0.4111\times 10^{-3}.
\end{equation}
Et pour faire la somme de cela avec \( x\oplus y\) nous devons le remettre sous la forme d'un \( 10^1\) :
\begin{equation}
    \fl(z)\to -0.00004\times 10^1
\end{equation}
(erreur de conversion), et en sommant on trouve
\begin{equation}
    (x\oplus y)\oplus z=0.140216\times 10^1,
\end{equation}
qui est encore arrondi. Le premier chiffre supprimé est un \( 6\), donc
\begin{equation}
    \fl(a)=0.1403\times 10^1,
\end{equation}

Le nom de l'erreur qui consiste à avoir \( x\oplus y=x\) est ``relation annirmale''.

Calculons \( b\).

Les nombres \( y\) et \( z\) ont même ordre de grandeur, donc pas d'erreur au moment de les mettre sous forme sommable.
\begin{subequations}
    \begin{align}
        \fl(x)+\fl(y)=0.00010\times 10^{-3}.
    \end{align}
\end{subequations}
Cela est renormalisé et arrondi : \( \fl(x)\oplus\fl(y)=0.1000\times 10^{-6}\).

Notons que nous avons ici commis potentiellement une erreur de cancellation parce que entre \( y\) et \( z\), il y a \( 3\) chiffres sur \( 4\) qui sont identiques. Seul le chiffre \( 1\) est significatif en réalité.

Il faut maintenant ajouter \( x\) à cela. D'abord
\begin{equation}
    \fl(x)=0.1403\times 10^1.
\end{equation}
Pour cette somme, il faudra remettre notre \( 0.1000\times 10^{-6}\) avec une puissance \( 10^1\). Et là, nous obtenons zéro parce que vraiment ce nombre est trop petit pour être écrit avec \( 10^1\). Résultat des courses :
\begin{equation}
    \fl(b)=0.1403\times 10^1.
\end{equation}


Dans le premier calcul nous avons deux ``relations anormales'' et dans le second nous en avons une plus une cancellation.

Nous préférons avoir deux relations anormales, parce que l'erreur de cancellation est plus grave : elle consiste à une perte de chiffre significatifs. Le fait est que faisant la différence à l'ordinateur nous avons obtenu \( 0.1\) qui est certes exact, mais qui est un coup de bol : la différence aurait aussi bien pu être \(0.19\) avec d'autres nombres, machinement égaux.

Note : avec les données ici, il n'y a en fait pas d'erreur de cancellation. Mais il y a une erreur potentielle de cancellation, potentiellement grave.

En ce qui concerne l'erreur relative. Dans la formule
\begin{equation}
    \epsilon_r=\frac{ | a-a^* | }{ | a | },
\end{equation}
la différence ne peut pas être calculée à la calculatrice justement parce qu'elle est très potentiellement sujette à erreur de cancellation.
\begin{equation}
    \epsilon_r=\frac{ | 0.1030001\times 10^1-0.1403\times 10^1 | }{ 0.14030001\times 10^1 }=\frac{ 0.1\times 10^{-6} }{ 0.14030001\times 10^1 }\simeq 0.712758\times 10^{-7}.
\end{equation}
En passant à \( 3\) chiffres significatifs, \( 0.713\times 10^{-7}\) (le premier chiffre supprimé est un \( 7\)).

\end{example}

\begin{example}
    Soient \( x=0.1\times 10^{21}\) et \( y=0.5\times 10^20\) et les expressions 
    \begin{enumerate}
        \item
            \( z_1=\frac{ x-y }{ y }+\frac{ x+y }{ x }\)
        \item
            \( z_2=\frac{ x^2+y^2 }{ xy }\).
    \end{enumerate}
    Ces deux expressions sont algébriquement équivalentes.
    
    \begin{enumerate}
        \item
            Calculer les valeurs.
        \item
            On suppose une machine en précision simple. Laquelle des deux expressions est préférable ?
    \end{enumerate}

    Pour \( z_1 \), en arithmétique exacte :
    \begin{equation}
        z_1=\frac{ 0.5\times 10^{20} }{ 0.5\times 10^{20} }+\frac{ 1.5\times 10^{20} }{ 1\times 10^{20} }=0.25\times 10^{1}.
    \end{equation}
    Le calcul exact de \( z_2\) donne la même chose.

    \begin{subproof}

        \item[Calcul de \( z_1\)]
        
            Les deux valeurs sont mémorisables et la différence \( x-y\) se fait sans erreurs de cancellation. Idem pour la somme \( x+y\). Idem pour les divisions.

        \item[Calcul de \( z_2\)]

            Pour faire \( x^2\), c'est pas possible parce que c'est de l'ordre de \( 10^{40}\) alors que nous sommes en précision simple. Idem pour le produit \( xy\).

    \end{subproof}
    Morale : \( z_2\) donne un \info{overflow} alors que \( z_1\) fonctionne de façon exacte.

    \begin{remark}
        En réalité le \( z_1\) n'est pas tout à fait calculable de façon exacte sur la machine parce qu'elle doit d'abord convertir en binaire, ce qui n'est pas toujours possible. Mais sur notre machine qui fonctionne en base \( 10\), il n'y a pas de problèmes.
    \end{remark}


\end{example}

\begin{example}

    Soit la fonction 
    \begin{equation}
        f(x)=2x^2-4x+2-e^{-x}.
    \end{equation}

    \begin{enumerate}
        \item
            Identifier la plus grande des solutions réelles de \( f(x)=0\).
        \item
            Effectuer une bisection pour la savoir.
        \item
            Sachant que
            \begin{equation}
                \alpha\simeq 1.358500220734946,
            \end{equation}
            quelle est l'erreur relative ?
    \end{enumerate}

    Note : si c'est pour chercher à la main des approximations pour démarrer, il est évidemment préférable de dessiner \( f_1(x)=2x^2-4x+2\) et \( f_2(x)=- e^{-x}\) séparément.

    Quoi qu'il en soit, voici un graphique :

\begin{center}
   \input{auto/pictures_tex/Fig_OQTEoodIwAPfZE.pstricks}
\end{center}

    Nous voyons trois racines : \( \alpha_1\in\mathopen[ 0,0.5 ,  \mathclose]\), \( \alpha_2\in\mathopen[ 1, 1.5 \mathclose]\) et \( \alpha_0\in\mathopen[ -4 , -3.5 \mathclose]\).

    La plus grande solution est \( \alpha_2\). Nous pouvons déjà remplir le tableau des précisions :

    \begin{equation*}
        \begin{array}[]{|c|c|c|c|c|c|}
            \hline
            n&a_n&b_n&x_n&g(x_n)&| b_n-a_n |\\
            \hline\hline
            <++>&<++>&<++>&<++>&<++>&0.5\\
            \hline
            <++>&<++>&<++>&<++>&<++>&0.25\\
            \hline
            <++>&<++>&<++>&<++>&<++>&0.125\\
            \hline
        \end{array}
    \end{equation*}

    Et nous calculons les valeurs de \( f\) aux points d'extrémité de l'intervalle. Note que seul le signe nous importe :
    \begin{subequations}
        \begin{align}
            f(1)\simeq -0.368\\
            f(1.5)\simeq 0.278.
        \end{align}
    \end{subequations}
    Voici donc le tableau avec le signe de \( f\) indiqué :

    \begin{equation*}
        \begin{array}[]{|c|c|c|c|c|c|}
            \hline
            n&a_n&b_n&x_n&g(x_n)&| b_n-a_n |\\
            \hline\hline
            0&1 (+)&1.5 (-)&<++>&-0.162\times 10^{0}&0.5\\
            \hline
            1&<++>&<++>&<++>&<++>&0.25\\
            \hline
            2&<++>&<++>&<++>&<++>&0.125\\
            \hline
        \end{array}
    \end{equation*}
    Puis :
    \begin{equation*}
        \begin{array}[]{|c|c|c|c|c|c|}
            \hline
            n&a_n&b_n&x_n&g(x_n)&| b_n-a_n |\\
            \hline\hline
            0&1 (+)&1.5 (-)&1.25 (-)&-0.162\times 10^{0}&0.5\\
            \hline
            1&<++>&<++>&<++>&<++>&0.25\\
            \hline
            2&<++>&<++>&<++>&<++>&0.125\\
            \hline
        \end{array}
    \end{equation*}
    Et enfin :
    \begin{equation*}
        \begin{array}[]{|c|c|c|c|c|c|}
            \hline
            n&a_n&b_n&x_n&g(x_n)&| b_n-a_n |\\
            \hline\hline
            0&1 (+)&1.5 (-)&1.25 (-)&-0.162\times 10^{0}&0.5\\
            \hline
            1&1.25 (-)&1.5(+)&1.375(+)&+0.284\times 10^{-1}&0.25\\
            \hline
            2&1.25(-)&1.375(+)&1.3125(-)&)0.738\times 10^{-1}&0.125\\
            \hline
        \end{array}
    \end{equation*}
    Note que les \( f(x_n)\) restent toujours du même ordre de grandeur. Si un moment on voit un \( 1.6\times 10^{7}\), c'est qu'une erreur a été commise.

    En ce qui concerne le calcul de l'erreur relative, la première chose à faire est de vérifier que le \( \alpha\) proposé est dans l'intervalle qui nous reste. Sinon c'est qu'une erreur a été commise.

    De plus notre approximation est \( x_n=1.3125\), dont déjà deux chiffres sont corrects. En deux itérations de bisection en partant de \( 0.5\), nous ne pouvons pas nous attendre à mieux.
    
\end{example}


%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\section{Approximations de fonctions}
%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\begin{enumerate}
    \item
        D'habitude on n'approxime pas une fonction sur tout son domaine, mais seulement sur une partie.
    \item
        Il y a le problème du choix de la classe des fonctions qui vont approximer. Nous allons travailler avec des polynômes.
    \item
        Il nous faut un critère disant si une approximation est bonne ou non.
\end{enumerate}

%---------------------------------------------------------------------------------------------------------------------------
\subsection{Critère d'interpolation}
%---------------------------------------------------------------------------------------------------------------------------

À partir de \( n+1\) abscisses points distinctes \( x_i\), nous calculons \( y_i=f(x_i)\). Il y a ce théorème qui dit qu'il existe un unique polynôme de degré (au plus) \( n+1\) passant par les points \( (x_i,y_i)\).

\begin{propositionDef}[Base de Lagrange]
    Étant donnés \( n+1\) valeurs distinctes \( x_i\), l'espace des polynômes de degré \( n\) admet la base
    \begin{equation}
        L_i^{(n)}(x)=\prod_{\substack{j=0\\j\neq i}}^n\frac{ x-x_j }{ x_i-x_j }
    \end{equation}
    pour \( i=0,\ldots, n\).
\end{propositionDef}

Soit par exemple les valeurs de \( f\) données dans
\begin{equation*}
    \begin{array}[]{c|c}
        x_i&y_i=f(x_i)\\
        \hline
        x_0=5&1\\
        x_1=-7&-23\\
        x_2=6&-54\\
        x_3=0&-954\\
    \end{array}
\end{equation*}

Les polynômes de Lagrange pour ces données dépendent seulement des \( x_i\), pas des \( y_i\). En particulier,
\begin{equation}
    L_0^{(3)}(x)=\frac{ (x-x_1)(x-x_2)(x-x_3) }{ (x_0-x_1)(x_0-x_2)(x_0-x_3) },
\end{equation}
etc.

La réponse est que
\begin{subequations}
    \begin{align}
        L_0^{(3)}(x)&=\frac{ x^3+13x^2+42x }{ 660 }\\
        L_1^{(3)}(x)&=\frac{ -x^3-x^2+30x  }{ 84 }\\
        etc.
    \end{align}
\end{subequations}

Ce qu'il y a de bien avec cette base est que en posant \( a_i=f(x_i)\) alors le polynôme
\begin{equation}
    \sum_{i=0}^na_iL_i^{(n)}(x)
\end{equation}
passe par les points \( (x_i,f(x_i))\). Du coup il suffit d'écrire
\begin{equation}
    P_3(x)=L_0^{(3)}(x)-23L_1^{(n)}(x)-54L_2^{(n)}(x)-954 L_3^{(n)}(x)=4x^3+35x^2-84x-954.
\end{equation}

Un inconvénient de cette base est qu'elle est complètement dépendante des points choisis. Si on ajoute un point ou qu'on en prend un à peine différent, tous les coefficients changent. Mais en pratique, ajouter des points est quelque chose qui arrive souvent parce que souvent, après avoir vu le résultat d'un polynôme d'interpolation, on veut ajouter un point pour avoir un meilleur résultat.

\begin{normaltext}
    Une habitude : le premier et le dernier nœud se choisissent aux extrémités de l'intervalle sur lequel nous voulons une approximation.

    Le but d'une approximation est d'avoir des approximations de \( f(x^*)\) pour des valeurs de \( x^*\) qui ne soit pas une des abscisses données (parce que sur ces points, le polynôme et la fonction sont égaux). Nous considérons donc
    \begin{equation}
        f(x^*)\simeq P_n(x^*).
    \end{equation}
    Si \( x^*\) est dans l'intervalle \( I= \mathopen[ x_{min} , x_{max} \mathclose]\) alors nous disons que nous calculons \( f\) par \defe{interpolation}{interpolation}. Si au contraire \( x^*\) est en dehors de cet intervalle nous parlons d'\defe{extrapolation}{extrapolation}.

    Si \( x^*\) est pris à l'extérieur de \( I\), alors l'erreur risque d'être très grande, surtout parce que les polynômes tendent tous vers \( \pm\infty\) lorsque \( x\to \pm\infty\).

    Autant l'interpolation via polynômes est le plus souvent valable, il faut garder à l'esprit que les extrapolations sont souvent mauvaises si \( x^*\) est trop loin des extrémités de \( I\).
\end{normaltext}

%---------------------------------------------------------------------------------------------------------------------------
\subsection{Base de Newton}
%---------------------------------------------------------------------------------------------------------------------------

Après la base canonique et la base de Lagrange, nous voyons la base de Newton. Soient encore \( n+1\) points donnés du graphe de \( f\).

\begin{definition}
    La \defe{base de Newton}{base!de Newton} pour les abscisses \( x_i\) est l'ensemble des polynômes suivants :
    \begin{equation}
        1,(x-x_0),(x-x_0)(x-x_1),\ldots,(x-x_0)(x-x_1)\ldots (x-x_{n-1})
    \end{equation}
\end{definition}
Notons que ces polynômes n'utilisent pas le dernier point des \( x_i\). Le polynôme passant par les points est
\begin{equation}
    P_n(x)=x_0+\sum_{i=1}^nc_i\prod_{j=0}^{n-1}(x-x_j).
\end{equation}
Le calcul des \( c_i\) n'est pas absolument évident. Mais si nous ajoutons un point d'interpolation, les polynômes déjà calculés sont encore bons; en particulier
\begin{equation}
    P_{n+1}(x)=P_n(x)+c_{n+1}\prod_{j=0}^{n}(x-x_j).
\end{equation}
Et cela est bien, parce que ça donne une façon de les calculer par récurrence.

Il y a plusieurs façons de calculer les \( c_i\).

Les différences divisées sont des façons d'approximer les dérivées.
\begin{definition}
    Soient \( n+1\) nœuds \( x_i\) pour la fonction \( f\). La \defe{différence divisée}{différence!divisée} sont :
    \begin{description}
        \item[Ordre \( 0\)]
            \begin{equation}
                f[x_i]=f(x_i)
            \end{equation}
        \item[Ordre \( 1\)]
            \begin{equation}
                f[x_i,x_j]=\frac{ f[x_i]-f[x_j] }{ x_i-x_j }.
            \end{equation}
        \item[Ordre \( 2\)]
            \begin{equation}
                f[x_i,x_j,x_k]=\frac{ f[x_i,x_j]-f[x_j,x_k] }{ x_i-x_k }.
            \end{equation}
        \item[Ordre \( n\)]
            \begin{equation}
                f[x_0,\ldots, x_n]=\frac{ f[x_0,\ldots, x_{n-1}]-f[x_1,\ldots, x_n] }{ x_0-x_n }.
            \end{equation}
    \end{description}
\end{definition}
Les ordres font référence à l'ordre de dérivation qui est approximé.

Nous avons alors
\begin{equation}
    c_i=f[x_0,\ldots, x_i].
\end{equation}
Cela donne effectivement une méthode de récurrence pour trouver les coefficients \( c_i\).

\begin{remark}
    Pour calculer \( c_0\), il faut seulement calculer \( f[x_0]=f(x_0)\). Mais pour calculer \( c_1\) il faut \( f[x_0] \) et \( f[x_1]\). Et pour \( c_2\) il faut \( f[x_0,x_1,x_2]\) qui demande \( f[x_0,x_1]\) et \( f[x_0,x_1]\), qui demande etc.

    Il faut donc calculer en réalité tous les \( f[x_i]\) pour terminer le calcul. Par contre, pour ajouter un point, il ne faut pas tout recalculer, et même pas tout conserver en mémoire. Il faut seulement garder en mémoire la dernière diagonale.
\end{remark}

\begin{example}

    Soit les nœuds
    \begin{equation*}
        \begin{array}[]{|c||c|}
            \hline
            x&f(x)\\
            \hline\hline
            3&1\\
            \hline
            1&-3\\
            \hline
            5&2\\
            \hline
            6&4\\
            \hline
        \end{array}
    \end{equation*}
    Trouver le polynôme d'interpolation via la base de Newton.


    \begin{equation*}
        \begin{array}[]{|c||c|c|c|}
            \hline
            x_i&f[x_i]&f[x_i,x_j]&f[x_i,x_j,x_k]\\
            \hline\hline
            3&1&\frac{ 1+3 }{ 2 }=2&\frac{ f[x_0,x_1]-f[x_1,x_2] }{ x_0-x_2 }=\frac{ 2-\frac{ 5 }{ 4 } }{ -2 }=-\frac{ 3 }{ 8 }\\
            \hline
            1&-3&\frac{ -3-2 }{ -4 }=\frac{ 5 }{ 4 }&\frac{ \frac{ 5 }{ 4 }-2 }{ -5 }=\frac{ 3 }{ 20 }\\
            \hline
            5&2&\frac{ 2-4 }{ -1 }=2&\frac{ f[x_0,x_1,x_2]-f[x_1,x_2,x_3] }{ x_0-x_3 }=\frac{ 4 }{ 40 }\\
            \hline
            6&4&<++>&<++>\\
            \hline
        \end{array}
    \end{equation*}
    Le polynôme d'interpolation sera
    \begin{equation}
        P_3(x)=c_0+c_1(x-x_0)+c_2(x-x_0)(x-x_1)+c_3(x-x_0)(x-x_1)(x-x_2).
    \end{equation}
    
\end{example}
<++>


Un exercice typique serait de donner tout pour \( 3\) points puis de demander le polynôme qui aurait un quatrième point.

%---------------------------------------------------------------------------------------------------------------------------
\subsection{Méthode des minima quadratiques}
%---------------------------------------------------------------------------------------------------------------------------

Soient \( m+1\) points connus sur le graphe de la fonction \( f\) que nous devons approximer. Au lieu d'exiger que notre approximation ne passe par tous les points, nous allons chercher une approximation qui minimise la somme des carrés des erreurs sur ces points.

Soit \( \mF\) une classe de fonctions dans laquelle nous allons chercher l'approximation. Nous cherchons \( g\in \mF\) qui minimise
\begin{equation}    \label{EQooJGQVooKwZZVJ}
   E(g)= \sum_{i=0}^m \big( f(x_i)-g(x_i) \big)^2\omega_i
\end{equation}
où \( \omega_i>0\) est une pondération. Souvent on prend \( \omega_i=1\), mais pas toujours. La fonction \( E\) sur \( \mF\) est la \defe{fonction d'erreur}{erreur}.

\begin{normaltext}
    À part dans les exercices à la main, le nombre de points est grand, du type du milliard. Il est bien entendu pas envisageable de faire passer un polynôme \emph{exactement} par un milliard de points, parce que cela demanderait un polynôme de degré un milliard.

    Plus généralement, d'un point de vue scientifique, avoir \( n\) paramètres libres pour \( n\) données expérimentales, ça ne passe pas Popper.

    Afin de faire de la science qui passe Popper nous nous restreignons à une classe de fonction \( \mF\) dont la dimension n'est pas grande : \( \dim( \mF)\ll m\). Et nous notons \( \dim(\mF)=n+1\).
\end{normaltext}

\begin{example}
    La qualité d'une expérience peut être influencée par des paramètres extérieurs comme l'humidité, le vent, etc. Donc il est normal d'avoir des expériences moins précises que d'autres. On le pèse moins.
\end{example}

\begin{example}
    Dans un questionnaire, il se met des questions volontairement contradictoires. Si quelqu'un répond «oui» aux deux questions, il y a une indication que la personne a répondu un peu n'importe comment, et il faut moins peser ses réponses.
\end{example}

Soit \( g\in \mF\), et une base \( \{ g_i \}_{i=0,\ldots, n}\) de \( \mF\). Nous écrivons
\begin{equation}
    g=a_0g_0+a_1g_1+\cdots +a_ng_n
\end{equation}
La fonction donnée \( E\) donnée en \eqref{EQooJGQVooKwZZVJ}, est, à partir du moment où \( \mF\) et une base sont choisis, une fonction des paramètres \( a_i\) que nous nommons \( F(a_0,\ldots, a_i)\). Il faut minimiser \( F\), c'est-à-dire poser
\begin{equation}
    \frac{ \partial F }{ \partial a_j }=0
\end{equation}
pour \( j=0,\ldots, n\). Cela sont \( n+1\) équations pour \( n+1\) inconnues. Notons que ces équations sont linéaires parce que chacun des termes est du type
\begin{equation}
    \left( f(x_i)-\sum_{j=0}^ma_jg_j(x_i) \right)^2,
\end{equation}
et lors de la dérivation par rapport à \( a_j\), nous obtenons du degré \( 1\).

%---------------------------------------------------------------------------------------------------------------------------
\subsection{Notre espace de Hilbert}
%---------------------------------------------------------------------------------------------------------------------------

Nous allons maintenant formaliser un peu tout cela. Dans \cite{ooPTFGooScbUWC} il est expliqué que si \( \omega\) est une fonction strictement positive, alors l'espace \( L^2_{\omega}\big( \mathopen[ a , b \mathclose] \big)\) dérivé de la norme
\begin{equation}
    \| f \|_{L^2_{\omega}}^2=\int_a^b| f(x) |^2\omega(x)dx
\end{equation}
est un espace de Hilbert. Nous allons tenter le coup avec \( \omega=\sum_{i=0}^m\omega_i\delta_{x_i}\) où \( \delta_a\) est la distribution de Dirac\footnote{Définition~\ref{DEFooUSTNooYEZfPN}.} centrée en \( a\).

Sur l'ensemble des fonctions \( \eR\to\eR\) nous considérons la relation d'équivalence \( f\sim g\) si \( f(x_i)=g(x_i)\) pour tout \( i=0,\ldots, m\). Nous notons \(  L^2_{\omega}  \) cet ensemble.

\begin{proposition}
    La formule
    \begin{equation}        \label{EQooVUKMooIjpkXO}
        \langle f, g\rangle =\sum_{i=0}^mf(x_i)g(x_i)\omega_i
    \end{equation}
    définit un produit scalaire sur \( L^2_{\omega}\). Ce dernier devient un espace de Hilbert.
\end{proposition}

\begin{proof}
    Pour être un produit scalaire (définition~\ref{DefVJIeTFj}), la forme considérée doit être symétrique et strictement définie positive. La symétrie de la formule \eqref{EQooVUKMooIjpkXO} ne fait pas de doute. Le fait que ce soit semi-défini positif non plus. Pour le strict,
    \begin{equation}
        \langle f, f\rangle =\sum_{i=0}^m| f(x_i) |^2\omega_i.
    \end{equation}
    Étant donné que \( \omega_i>0\) pour tout \( i\), l'annulation de \( \langle f, f\rangle \) implique l'annulation de \( f(x_i)\) pour tout \( i\). Cela signifie que \( f\) est dans la classe de \( 0\) et donc est nul dans \( L^2_{\omega}\).

    En ce qui concerne la complétude, la proposition~\ref{PROPooGJDTooXOoYfw} répond à notre place, étant donné que \( L^2_{\omega}\) est de dimension finie. Une base est donnée par exemple par \( e_i(x)=\delta_{x,x_{i}}\). Ici le \( \delta\) est celui de Kronecker, et non celui de Dirac.
\end{proof}

\begin{lemma}
    Si la classe de fonctions \( \mF\) est un sous-espace vectoriel de \( L^2_{\omega}\) et si \( f\in L^2_{\omega}\) il existe un unique élément \( g\) de \( \mF\) minimisant la distance à \( f\).
\end{lemma}

\begin{proof}
    Le théorème de projection (au choix~\ref{ThoWKwosrH} ou~\ref{ThoProjOrthuzcYkz}) nous assure l'existence et l'unicité d'un élément de \( \mF\) minimisant la distance à \( f\in L^2_{\omega}\).
\end{proof}

\begin{normaltext}
    Ce lemme est gentil, mais ne nous donne pas de méthodes pour trouver ce minimum. Nous allons donc écrire explicitement un système d'équations permettant de le trouver. Si \( \{ g_{\alpha} \} \) est une base (finie) de \( \mF\) alors nous cherchons le minimisant sous la forme \( f=\sum_{\alpha}a_{\alpha}g_{\alpha}\).

    Nous devons minimiser
    \begin{equation}
        E(g)=\sum_{i=0}^m\big( f(x_i)-g(x_i) \big)^2\omega_i=\sum_{i=0}^m\big( f(x_i)-\sum_{\alpha}a_{\alpha}g_{\alpha}(x_i) \big)^2\omega_i.
    \end{equation}
    Vu que cela est maintenant plutôt une fonction des coefficients \( a_{\alpha}\) que de la fonction \( g\) nous la notons \( F(a_0,\ldots, a_n)\). Il s'agit d'étudier le système d'équations
    \begin{equation}
        \frac{ \partial F }{ \partial a_{\alpha} }=0.
    \end{equation}
    Un tout petit peu de calcul mène au système
    \begin{equation}
        \sum_i\sum_{\beta}a_{\beta}\omega_ig_{\alpha}(x_i)g_{\beta}(x_i)=\sum_{i}\omega_ig_{\alpha}(x_i)f(x_i).
    \end{equation}
    À droite nous reconnaissons \( \langle f, g_{\alpha}\rangle \). et à gauche, \( \sum_{\beta}a_{\beta}\langle g_{\alpha}, g_{\beta}\rangle \). Donc le système s'écrit
    \begin{equation}
        \sum_{\beta}a_{\beta}\langle g_{\alpha}, g_{\beta}\rangle =\langle f, g_{\alpha}\rangle .
    \end{equation}
    Il y a une équation pour chaque valeur de \( \alpha\).

    La matrice \( A\in\eM(n+1),\eR\) donnée par  \( \langle g_{\alpha}, g_{\beta}\rangle \) étant strictement définie positive (c'est un produit scalaire), le système a une unique solution. Et comme cette matrice est de plus symétrique, elle est diagonalisable par le théorème spectral~\ref{ThoeTMXla}. Toutes ses valeurs propres sont strictement positives.

    Notons pour la curiosité que si l'on considère la matrice \( B\in\eM(m\times n)\) donnée par
    \begin{equation}
        B_{ij}=\sqrt{ \omega_i }g_j(x_l),
    \end{equation}
    alors nous avons \( A=B^tB\).
\end{normaltext}

%---------------------------------------------------------------------------------------------------------------------------
\subsection{Droite de régression}
%---------------------------------------------------------------------------------------------------------------------------

La droite de régression est la cas particulier \( n=1\), c'est-à-dire un système \( 2\times 2\). Nous cherchons \( P=a_0+a_1x\). Et la base choisie est \( g_0(x)=1\), \( g_1(x)=x\). Nous avons
\begin{subequations}
    \begin{align}
        \langle g_0, g_0\rangle =\sum_i\omega_ig_0(x_i)g_0(x_i)=\sum_i\omega_i\\
        \langle g_0, g_1\rangle =\sum_i\omega_ix_i\\
        \langle g_1, g_1\rangle =\sum_i\omega_ix_i^2.
    \end{align}
\end{subequations}
Donc pour approximer une fonction \( f\) il faut résoudre le système
\begin{equation}
    \begin{pmatrix}
        \sum_i\omega_i    &   \sum_i\omega_ix_i    \\
        \sum_i\omega_ix_i    &   \sum_i\omega_ix_i^2
    \end{pmatrix}\begin{pmatrix}
        a_0    \\
        a_1
    \end{pmatrix}=
    \begin{pmatrix}
        \langle f, g_0\rangle     \\
        \langle f, g_1\rangle
    \end{pmatrix}.
\end{equation}

Pour calculer les produits \( \langle f, g_{\alpha}\rangle \) il suffit de savoir \( f\) sur les points \( x_i\). Et encore heureux, parce que toute la méthode est basée sur le fait que nous ne connaissons pas \( f\) ailleurs. C'est pour cela que nous avons défini \( L^2_{\omega}\) comme un ensemble quotient.

\begin{example}
    Faisons la droite de régression pour les données avec tous les poids \( \omega_i=1\).
    \begin{equation*}
        \begin{array}[]{c|c}
            x_i&f(x_i)\\
            \hline\hline
            -5&18\\
            -3&7\\
            1&0\\
            3&7\\
            4&16\\
            6&50\\
            8&67\\
        \end{array}
    \end{equation*}
    Nous avons
    \begin{subequations}
        \begin{align}
            \langle g, g_0\rangle =\sum_if(x_i)=165\\
            \langle f, f_1\rangle =\sum_if(x_i)x_i=810.
        \end{align}
    \end{subequations}
    et donc le système
    \begin{equation}
        \begin{pmatrix}
            7    &   14    \\
            14    &   160
        \end{pmatrix}
        \begin{pmatrix}
            a_0    \\
            a_1
        \end{pmatrix}=\begin{pmatrix}
            165    \\
            810
        \end{pmatrix}
    \end{equation}
    dont résolution donne la droite de régression.
\end{example}

\begin{proposition}
    Si tous les poids sont identiques, alors la droite de régression passe par le barycentre des points donnés :
    \begin{subequations}
        \begin{numcases}{}
            x_M=\frac{1}{ m+1 }\sum_{i=0}^mx_i\\
            y_M=\frac{1}{ m+1 }\sum_{i=0}^my_i.
        \end{numcases}
    \end{subequations}
\end{proposition}
Cela donne une vérification possible de la réponse trouvée.

\begin{definition}
    L'\defe{erreur quadratique}{erreur!quadratique} est la fonction \( F(a_0,\ldots, a_n)\) dont il est question plus haut. Et si une solution est connue, son erreur quadratique est la valeur de $F$ pour cette solution.
\end{definition}
